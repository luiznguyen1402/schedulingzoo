reduction = \
{('', ''): 'R',
 ('', '2-dim partial order'): True,
 ('', 'Am-order'): True,
 ('', 'DC-graph'): True,
 ('', 'M_j'): True,
 ('', 'bounded height'): True,
 ('', 'chains'): True,
 ('', 'fix_j'): True,
 ('', 'interval order'): True,
 ('', 'intree'): True,
 ('', 'k-dim partial order'): True,
 ('', 'l'): True,
 ('', 'l=1'): True,
 ('', 'l>0'): True,
 ('', 'l\\leq0'): True,
 ('', 'l_{ij}'): True,
 ('', 'l_{ij}>0'): True,
 ('', 'l_{ij}\\leq0'): True,
 ('', 'level order'): True,
 ('', 'opposing forest'): True,
 ('', 'outtree'): True,
 ('', 'over-interval order'): True,
 ('', 'prec'): True,
 ('', 'quasi-interval order'): True,
 ('', 'r_j'): True,
 ('', 's_j=1'): True,
 ('', 's_j=s'): True,
 ('', 's_{ij}=1'): True,
 ('', 's_{ij}=s'): True,
 ('', 'size_j'): True,
 ('', 'size_j\\in\\{1,m\\}'): True,
 ('', 'sp-graph'): True,
 ('', 't_j'): True,
 ('', 't_j\\in\\{T_1,T_2\\}'): True,
 ('', 't_k'): True,
 ('', 't_{jkl}'): True,
 ('', 't_{jkl}=T'): True,
 ('', 't_{jkl}=t_{jlk}'): True,
 ('', 't_{jk}'): True,
 ('', 't_{jk}=T'): True,
 ('', 't_{kl}'): True,
 ('', 't_{kl}=t_{lk}'): True,
 ('', 'tree'): True,
 ('1', ''): ('or',
             ('or',
              ('or',
               ('and', ('not', 'processing times'), ('not', 'pmtn')),
               ('and', ('not', 'processing times'), ('not', 'pmtn'))),
              ('and', ('not', 'processing times'), ('not', 'pmtn'))),
             ('and', ('not', 'processing times'), ('not', 'pmtn'))),
 ('1', '2'): ('and', ('not', 'processing times'), ('not', 'pmtn')),
 ('1', '3'): ('and', ('not', 'processing times'), ('not', 'pmtn')),
 ('1', '4'): ('and', ('not', 'processing times'), ('not', 'pmtn')),
 ('1', '5'): ('and', ('not', 'processing times'), ('not', 'pmtn')),
 ('1', 'm'): ('or',
              ('or',
               ('or',
                ('and', ('not', 'processing times'), ('not', 'pmtn')),
                ('and', ('not', 'processing times'), ('not', 'pmtn'))),
               ('and', ('not', 'processing times'), ('not', 'pmtn'))),
              ('and', ('not', 'processing times'), ('not', 'pmtn'))),
 ('2', ''): True,
 ('2', '3'): ('and', ('not', 'processing times'), ('not', 'pmtn')),
 ('2', '4'): ('and', ('not', 'processing times'), ('not', 'pmtn')),
 ('2', '5'): ('and', ('not', 'processing times'), ('not', 'pmtn')),
 ('2', 'm'): True,
 ('2-dim partial order', 'k-dim partial order'): True,
 ('2-dim partial order', 'prec'): True,
 ('3', ''): True,
 ('3', '4'): ('and', ('not', 'processing times'), ('not', 'pmtn')),
 ('3', '5'): ('and', ('not', 'processing times'), ('not', 'pmtn')),
 ('3', 'm'): True,
 ('4', ''): True,
 ('4', '5'): ('and', ('not', 'processing times'), ('not', 'pmtn')),
 ('4', 'm'): True,
 ('5', ''): True,
 ('5', 'm'): True,
 ('Am-order', 'prec'): True,
 ('C_{\\max}', 'F_{\\max}'): True,
 ('C_{\\max}', 'L_{\\max}'): True,
 ('C_{\\max}', '\\max w_jF_j'): True,
 ('C_{\\max}', '\\sum T_j'): True,
 ('C_{\\max}', '\\sum U_j'): True,
 ('C_{\\max}', '\\sum w_jT_j'): True,
 ('C_{\\max}', '\\sum w_jU_j'): True,
 ('DC-graph', '2-dim partial order'): True,
 ('DC-graph', 'k-dim partial order'): True,
 ('DC-graph', 'prec'): True,
 ('DC-graph', 'sp-graph'): True,
 ('F', 'J'): True,
 ('F_{\\max}', '\\max w_jF_j'): True,
 ('L_{\\max}', '\\sum T_j'): True,
 ('L_{\\max}', '\\sum w_jT_j'): True,
 ('M_j', ''): 'R',
 ('M_j', 'M_j'): 'R',
 ('M_j', 'fix_j'): 'R',
 ('P', 'Q'): True,
 ('P', 'R'): True,
 ('Q', 'R'): True,
 ('\\sum C_j', '\\sum F_j'): True,
 ('\\sum C_j', '\\sum T_j'): True,
 ('\\sum C_j', '\\sum w_jC_j'): True,
 ('\\sum C_j', '\\sum w_jF_j'): True,
 ('\\sum C_j', '\\sum w_jT_j'): True,
 ('\\sum F_j', '\\sum w_jF_j'): True,
 ('\\sum T_j', '\\sum w_jT_j'): True,
 ('\\sum U_j', '\\sum w_jU_j'): True,
 ('\\sum w_jC_j', '\\sum w_jF_j'): True,
 ('\\sum w_jC_j', '\\sum w_jT_j'): True,
 ('batch(\\infty)', 'batch(b)'): True,
 ('bounded height', 'prec'): True,
 ('chains', '2-dim partial order'): True,
 ('chains', 'DC-graph'): True,
 ('chains', 'intree'): True,
 ('chains', 'k-dim partial order'): True,
 ('chains', 'level order'): True,
 ('chains', 'opposing forest'): True,
 ('chains', 'outtree'): True,
 ('chains', 'prec'): True,
 ('chains', 'sp-graph'): True,
 ('chains', 'tree'): True,
 ('d_j=d', ''): True,
 ('d_j\\leq r_j+2', ''): True,
 ('d_j\\leq r_j+2', 'd_j\\leq r_j+3'): True,
 ('d_j\\leq r_j+2', 'd_j\\leq r_j+4'): True,
 ('d_j\\leq r_j+3', ''): True,
 ('d_j\\leq r_j+3', 'd_j\\leq r_j+4'): True,
 ('d_j\\leq r_j+4', ''): True,
 ('interval order', 'Am-order'): True,
 ('interval order', 'over-interval order'): True,
 ('interval order', 'prec'): True,
 ('interval order', 'quasi-interval order'): True,
 ('intree', '2-dim partial order'): True,
 ('intree', 'k-dim partial order'): True,
 ('intree', 'opposing forest'): True,
 ('intree', 'prec'): True,
 ('intree', 'sp-graph'): True,
 ('intree', 'tree'): True,
 ('k-dim partial order', 'prec'): True,
 ('l', 'l_{ij}'): True,
 ('l=1', 'l'): True,
 ('l=1', 'l>0'): True,
 ('l=1', 'l_{ij}'): True,
 ('l=1', 'l_{ij}>0'): True,
 ('l>0', 'l'): True,
 ('l>0', 'l_{ij}'): True,
 ('l>0', 'l_{ij}>0'): True,
 ('l\\leq0', 'l'): True,
 ('l\\leq0', 'l_{ij}'): True,
 ('l\\leq0', 'l_{ij}\\leq0'): True,
 ('l_{ij}>0', 'l_{ij}'): True,
 ('l_{ij}\\leq0', 'l_{ij}'): True,
 ('level order', 'prec'): True,
 ('m', ''): True,
 ('n=2', ''): True,
 ('n=2', 'n=3'): True,
 ('n=2', 'n=k'): True,
 ('n=3', ''): True,
 ('n=3', 'n=k'): True,
 ('n=k', ''): True,
 ('opposing forest', '2-dim partial order'): True,
 ('opposing forest', 'k-dim partial order'): True,
 ('opposing forest', 'prec'): True,
 ('opposing forest', 'sp-graph'): True,
 ('outtree', '2-dim partial order'): True,
 ('outtree', 'k-dim partial order'): True,
 ('outtree', 'opposing forest'): True,
 ('outtree', 'prec'): True,
 ('outtree', 'sp-graph'): True,
 ('outtree', 'tree'): True,
 ('over-interval order', 'Am-order'): True,
 ('over-interval order', 'prec'): True,
 ('p_j=1', ''): True,
 ('p_j=1', 'p_j=p'): True,
 ('p_j=1', 'p_j\\in\\{1,2\\}'): True,
 ('p_j=p', ''): True,
 ('p_j\\in\\{1,2\\}', ''): True,
 ('p_{ij}=1', ''): True,
 ('p_{ij}=1', 'p_{ij}=p'): True,
 ('p_{ij}=p', ''): True,
 ('p_{ij}\\in\\{p_j,\\infty\\}', ''): True,
 ('p_{kj}=p_j', ''): True,
 ('quasi-interval order', 'Am-order'): True,
 ('quasi-interval order', 'over-interval order'): True,
 ('quasi-interval order', 'prec'): True,
 ('s_j=1', 's_j=s'): True,
 ('s_{ij}=1', 's_{ij}=s'): True,
 ('size_j\\in\\{1,m\\}', 'size_j'): True,
 ('sp-graph', '2-dim partial order'): True,
 ('sp-graph', 'k-dim partial order'): True,
 ('sp-graph', 'prec'): True,
 ('t_j', 't_{jkl}'): True,
 ('t_j', 't_{jkl}=t_{jlk}'): True,
 ('t_j', 't_{jk}'): True,
 ('t_j\\in\\{T_1,T_2\\}', 't_j'): True,
 ('t_j\\in\\{T_1,T_2\\}', 't_{jkl}'): True,
 ('t_j\\in\\{T_1,T_2\\}', 't_{jkl}=t_{jlk}'): True,
 ('t_j\\in\\{T_1,T_2\\}', 't_{jk}'): True,
 ('t_k', 't_{jk}'): True,
 ('t_{jkl}=T', 't_j'): True,
 ('t_{jkl}=T', 't_j\\in\\{T_1,T_2\\}'): True,
 ('t_{jkl}=T', 't_{jkl}'): True,
 ('t_{jkl}=T', 't_{jkl}=t_{jlk}'): True,
 ('t_{jkl}=T', 't_{jk}'): True,
 ('t_{jkl}=T', 't_{kl}'): True,
 ('t_{jkl}=T', 't_{kl}=t_{lk}'): True,
 ('t_{jkl}=t_{jlk}', 't_{jkl}'): True,
 ('t_{jk}=T', 't_j'): True,
 ('t_{jk}=T', 't_j\\in\\{T_1,T_2\\}'): True,
 ('t_{jk}=T', 't_k'): True,
 ('t_{jk}=T', 't_{jkl}'): True,
 ('t_{jk}=T', 't_{jkl}=t_{jlk}'): True,
 ('t_{jk}=T', 't_{jk}'): True,
 ('t_{kl}', 't_{jkl}'): True,
 ('t_{kl}=t_{lk}', 't_{jkl}'): True,
 ('t_{kl}=t_{lk}', 't_{jkl}=t_{jlk}'): True,
 ('t_{kl}=t_{lk}', 't_{kl}'): True,
 ('tree', '2-dim partial order'): True,
 ('tree', 'k-dim partial order'): True,
 ('tree', 'opposing forest'): True,
 ('tree', 'prec'): True,
 ('tree', 'sp-graph'): True}
explanation = \
{'': 'no setup',
 '1': 'Single machine.',
 '2': 'm=2 machines.',
 '2-dim partial order': 'A 2-dimensional partial order is a k-dimensional '
                        'partial order for k=2.',
 '3': 'm=3 machines.',
 '4': 'm=4 machines.',
 '5': 'm=5 machines.',
 'Am-order': 'Am orders are a superclass of over-interval orders defined in '
             'Moukrim and Quilliot: A relation between multiprocessor '
             'scheduling and linear programming. Order, 14(3):269-278, 1997.',
 'C_{\\max}': 'Makespan. Minimize the maximum completion time over all jobs.',
 'C_{\\min}': 'Santha Claus. Maximizes the minimum machine load.',
 'DC-graph': 'A divide-and-conquer graph is a subclass of series-parallel '
             'graphs defined in Kubiak et al.: Optimality of HLF for '
             'scheduling divide-and-conquer UET task graphs on identical '
             'parallel processors. Discrete Optimization, 6:79-91, 2009.',
 'F': 'Flow shop. Every job $j$ consists of $n_j$ operations $O_{ij}$ for '
      '$k=1,\\ldots,m$, to be scheduled in that order.  Operation $O_{ij}$ '
      'must be processed for $p_{ij}$ units on machine $i$.',
 'F_{\\max}': 'Maximum flow time. The flow time of a job is difference between '
              'its completion time and its release time, i.e. $F_j=C_j-r_j$. '
              'The goal is to minimize the maximum flow time over all jobs.',
 'J': 'Job shop. Every job $j$ consists of $n_j$ operations $O_{kj}$ for '
      '$k=1,\\ldots,n_j$, to be scheduled in that order.  Operation $O_{kj}$ '
      'must be processed for $p_{kj}$ units on a dedicated machine $\\mu_{kj}$ '
      "with $\\mu_{kj}\\neq \\mu_{k'j}$ for $k\\neq k'$.",
 'L_{\\max}': 'Maximum lateness. Every job $j$ is given a due date $d_j$. The '
              'goal is to minimize $\\max_j C_j-d_j$ where $C_j$ is the '
              'completion time of job $j$. By the use of binary search, this '
              'objective is essentially equivalent with testing feasibility '
              'when $d_j$ represent strict deadlines.',
 'M_j': 'Multipurpose machines. Every job $j$ needs to be scheduled on one '
        'machine out of a given set $M_j\\subseteq\\{1,\\ldots,m\\}$.  '
        "Sometimes also denoted by 'M_j'.",
 'O': 'Open shop. Every job $j$ consists of $m$ operations $O_{ij}$ for '
      '$i=1,\\ldots,m$.  The operations can be scheduled in any order. '
      'Operation $O_{ij}$ must be processed for $p_{ij}$ units on machine $i$.',
 'P': 'Parallel identical machines. We are given $m$ machines. Processing time '
      'of job $j$ is $p_j$, independent of the machine.',
 'Q': 'Related machines. We are given $m$ machines, each with given speed '
      '$s_1,\\ldots,s_m$. Processing time of job $j$ on machine $i$ is '
      '$p_j/s_j$.',
 'R': 'We are given $m$ unrelated machines. Processing time of job $j$ on '
      'machine $i$ is some given length $p_{ij}$.',
 'R1': 'We are given a single robot that can transport the operations of a job '
       'from one machine to another. The robot can make at most one '
       'transportation per time.',
 'S1': 'Single server.',
 '\\max w_jF_j': 'Maximum weighted flow time. Every job $j$ is given a '
                 'priority weight $w_j$.  The flow time of a job is difference '
                 'between its completion time and its release time, i.e. '
                 '$F_j=C_j-r_j$.',
 '\\sum C_j': 'Sum of completion times. $C_j$ denotes the completion time of '
              'job $j$ in some schedule. The goal is to minimize the total '
              'completion time.',
 '\\sum F_j': 'Total flow time. The flow time of a job is difference between '
              'its completion time and its release time, i.e. $F_j=C_j-r_j$. '
              'The goal is to minimize the total flow time over all jobs.',
 '\\sum T_j': 'Maximum tardiness. Every job $j$ is given a due date $d_j$. The '
              'goal is to minimize $\\sum_j \\max\\{0, C_j-d_j\\}$ where $C_j$ '
              'is the completion time of job $j$.',
 '\\sum U_j': 'Throughput. Every job is given a due date $d_j$.  The goal is '
              'to maximize the number of jobs that complete on time.',
 '\\sum w_jC_j': 'Weighted sum of completition times. Every job $j$ is given a '
                 'priority weight $w_j$. $C_j$ denotes the completion time of '
                 'job $j$ in some schedule.',
 '\\sum w_jF_j': 'Weighted flow time. Every job $j$ is given a priority weight '
                 '$w_j$.  The flow time of a job is difference between its '
                 'completion time and its release time, i.e. $F_j=C_j-r_j$.',
 '\\sum w_jT_j': 'Weighted maximum tardiness. Every job $j$ is given a due '
                 'date $d_j$. The goal is to minimize $\\sum_j w_j \\max\\{0, '
                 'C_j-d_j\\}$ where $C_j$ is the completion time of job $j$ '
                 'and $w_j$ its priority weight.',
 '\\sum w_jU_j': 'Weighted throughput. Every job is given a due date $d_j$.  '
                 'The goal is to maximize the total weight of jobs that '
                 'complete on time.',
 'batch(\\infty)': 'Parallel batching. The jobs have to be processed in '
                   'batches. There is no limit on the number of jobs in a '
                   'batch. The processing time of a batch is the maximal '
                   'processing time over all jobs in the batch.  If a new '
                   'batch is started, a constant setup time $s$ occurs.',
 'batch(b)': 'Parallel batching. The jobs have to be processed in batches. A '
             'batch consists of maximal b jobs. The processing time of a batch '
             'is the maximal processing time over all jobs in the batch.  If a '
             'new batch is started, a constant setup time $s$ occurs.',
 'bounded height': 'Given precedence relation where the longest directed path '
                   'is bounded by a constant.',
 'chains': 'Given precedence relation in form of chains (indegrees and '
           'outdegrees are at most 1).',
 'd_j=d': 'Common due date $d$ to every job. Can be a deadline depending on '
          'the objective function.',
 'd_j\\leq r_j+2': 'The span between deadline and release time of every job is '
                   'at most 2.  These are called 2-bounded instances.',
 'd_j\\leq r_j+3': 'The span between deadline and release time of every job is '
                   'at most 3.  These are called 3-bounded instances.',
 'd_j\\leq r_j+4': 'The span between deadline and release time of every job is '
                   'at most 4.  These are called 4-bounded instances.',
 'fix_j': 'Multiprocessor tasks. Every job $j$ is given with a set of machines '
          '$fix_j\\subseteq\\{1,\\ldots,m\\}$, and needs simultaneously all '
          "these machines for execution. Sometimes also denoted by 'MPT'.",
 'interval order': 'Given precedence relation for which one can associate to '
                   'each vertex an interval in the real '
                   'line,                     and there is a precedence '
                   'between x and y if and only if the half open intervals '
                   'x=[s_x,e_x) and y=[s_y,e_y) are such that e_x is smaller '
                   'than or equal to s_y.',
 'intree': 'Given general precedence relation in form of an intree (outdegrees '
           'are at most 1).',
 'k-dim partial order': 'A poset is a k-dimensional partial order iff it can '
                        'be embedded into the k-dimensional Euclidian space in '
                        'such a way that                     each node is '
                        'represented by a k-dimensional point and there is a '
                        'precedence between two nodes i and j iff for any '
                        'dimension the coordinate of i is smaller than or '
                        'equal to the one of j.',
 'l': 'job independent time lags. In a machine problem with time-lags for '
      'every job pair $i\\prec j$ in the precedence relation, job $j$ can '
      'start only at least $l_{ij}$ units after the completion of job $i$.  '
      'Default timelag is zero.  Also denoted as $c$ for communication time.',
 'l=1': 'unit time lags. In a machine problem with time-lags for every job '
        'pair $i\\prec j$ in the precedence relation, job $j$ can start only '
        'at least $l_{ij}$ units after the completion of job $i$.  Default '
        'timelag is zero.  Also denoted as $c$ for communication time.',
 'l>0': 'job independent positive time lags. In a machine problem with '
        'time-lags for every job pair $i\\prec j$ in the precedence relation, '
        'job $j$ can start only at least $l_{ij}$ units after the completion '
        'of job $i$.  Default timelag is zero.  Also denoted as $c$ for '
        'communication time.',
 'l\\leq0': 'job independent negative time lags. In a machine problem with '
            'time-lags for every job pair $i\\prec j$ in the precedence '
            'relation, job $j$ can start only at least $l_{ij}$ units after '
            'the completion of job $i$.  Default timelag is zero.  Also '
            'denoted as $c$ for communication time.',
 'l_{ij}': 'arbitrary time lags. In a machine problem with time-lags for every '
           'job pair $i\\prec j$ in the precedence relation, job $j$ can start '
           'only at least $l_{ij}$ units after the completion of job $i$.  '
           'Default timelag is zero.  Also denoted as $c$ for communication '
           'time.',
 'l_{ij}>0': 'arbitrary positive time lags. In a machine problem with '
             'time-lags for every job pair $i\\prec j$ in the precedence '
             'relation, job $j$ can start only at least $l_{ij}$ units after '
             'the completion of job $i$.  Default timelag is zero.  Also '
             'denoted as $c$ for communication time.',
 'l_{ij}\\leq0': 'arbitrary negative time lags. In a machine problem with '
                 'time-lags for every job pair $i\\prec j$ in the precedence '
                 'relation, job $j$ can start only at least $l_{ij}$ units '
                 'after the completion of job $i$.  Default timelag is zero.  '
                 'Also denoted as $c$ for communication time.',
 'level order': 'Given precedence relation where each vertex of a given level '
                'l (i.e. the length of the longest directed path starting from '
                'this vertex is l) is a predecessor of all the vertices of '
                'level l-1.',
 'm': 'Fixed number of machines $m$.  Used for complexity results which are '
      'polynomial in the number of jobs, but not in the number of machines.',
 'n=2': 'The input consists of only 2 jobs.',
 'n=3': 'The input consists of only 3 jobs.',
 'n=k': 'The input consists of only k jobs.',
 'no-idle': 'No machine is ever idle between two executions.',
 'no-wait': 'The operation $O_{k+1,i}$ must start exactly when operation '
            "$O_{k,i}$ completes.  Sometimes also denoted as 'nwt'.",
 'online-r_j': 'This is an online problem. Jobs are revealed at their release '
               'times.',
 'opposing forest': 'Given general precedence relation in form of a collection '
                    'of intrees and outtrees.',
 'outtree': 'Given general precedence relation in form of an outtree '
            '(indegrees are at most 1).',
 'over-interval order': 'Over-interval orders are a superclass of '
                        'quasi-interval orders defined in Chardon and Moukrim: '
                        'The Coffman-Graham algorithm optimally solves UET '
                        'task systems with overinterval orders, SIAM Journal '
                        'on Discrete Mathematics, 19(1):109-121, 2005.',
 'p_j=1': 'Unit processing times.',
 'p_j=p': 'Equal processing times. All processing times are equal to some '
          'given $p$.',
 'p_j\\in\\{1,2\\}': 'Every job has processing time either 1 or 2.',
 'p_{ij}=1': 'Unit processing times.',
 'p_{ij}=p': 'Equal processing times. All processing times are equal to some '
             'given $p$.',
 'p_{ij}\\in\\{p_j,\\infty\\}': 'Restricted machine model. Every job j comes '
                                'with a set of machines on which it is allowed '
                                'to be scheduled.  Sometimes also denoted as '
                                'machine environment B.',
 'p_{kj}=p_j': 'All operations of a same job $j$ have the same processing '
               'time.',
 'pmtn': 'Jobs can be preempted and resumed possibly on another machine. '
         "Sometimes also denoted by 'prmp'",
 'prec': 'Given general precedence relation.  If $i\\prec j$ then starting '
         'time of $j$ should be not earlier than completion time of $i$.',
 'quasi-interval order': 'Quasi-interval orders are a superclass of interval '
                         'orders defined in Moukrim: Optimal scheduling on '
                         'parallel machines for a new order class, Operations '
                         'Research Letters, 24(1):91-95, 1999.',
 'r_j': 'Job $j$ cannot be scheduled before given release time $r_j$.',
 'rcrc': 'Recirculation, also called Flexible job shop. The promise on $\\mu$ '
         "is lifted and for some pairs $k\\neq k'$  we might have $\\mu_{kj}= "
         "\\mu_{k'j}$.",
 'restarts': 'Jobs can be preempted and restarted from the beginning. '
             'Sometimes called preemption with restarts as opposed to '
             'preemption with resume.',
 's-batch': 'Serial batching. The jobs have to be processed in batches. The '
            'processing time of a batch is the total processing time over all '
            'jobs in the batch.  If a new batch is started, a constant setup '
            'time $s$ occurs.',
 's_j=1': 'unit setup times.A single server is loading the job $J_j$ or '
          'operation $O_{ij}$ on the machine which requires a setup time. '
          'These setup periods cannot overlap.',
 's_j=s': 'equal setup times. A single server is loading the job $J_j$ or '
          'operation $O_{ij}$ on the machine which requires a setup time. '
          'These setup periods cannot overlap.',
 's_{ij}=1': 'unit setup times.A single server is loading the job $J_j$ or '
             'operation $O_{ij}$ on the machine which requires a setup time. '
             'These setup periods cannot overlap.',
 's_{ij}=s': 'equal setup times. A single server is loading the job $J_j$ or '
             'operation $O_{ij}$ on the machine which requires a setup time. '
             'These setup periods cannot overlap.',
 'size_j': 'Multiprocessor tasks on identical parallel machines. The execution '
           'of job $j$ is done simultaneously on $size_j$ parallel machines.',
 'size_j\\in\\{1,m\\}': 'Multiprocessor tasks on identical parallel machines. '
                        'Some jobs need all machines in parallel for their '
                        'execution, some need only a single machine.',
 'sp-graph': 'Given precedence relation in form of a series parallel graph.',
 't_j': 'Job dependent transportation delay. Between the completion of '
        'operation $O_{kj}$ of job $j$ on machine $k$ and the start of '
        'operation $O_{l,j}$ of job $j$ on machine $l$, there is a '
        'transportation delay of at least $t_{j}$ units.',
 't_j\\in\\{T_1,T_2\\}': 'Job dependent transportation delay out of two '
                         'values. Between the completion of operation $O_{kj}$ '
                         'of job $j$ on machine $k$ and the start of operation '
                         '$O_{l,j}$ of job $j$ on machine $l$, there is a '
                         'transportation delay of at least '
                         '$t_{j}\\in\\{T_1,T_2\\}$ units.',
 't_k': 'Machine dependent transportation delay. Between the completion of '
        'operation $O_{kj}$ of job $j$ on machine $k$ and the start of '
        'operation $O_{k+1,j}$ of job $j$ on machine $k+1$, there is a '
        'transportation delay of at least $t_{k}$ units.',
 't_{jkl}': 'Between the completion of operation $O_{kj}$ of job $j$ on '
            'machine $k$ and the start of operation $O_{l,j}$ of job $j$ on '
            'machine $l$, there is a transportation delay of at least '
            '$t_{jkl}$ units.',
 't_{jkl}=T': 'Uniform transportation delay. Between the completion of '
              'operation $O_{kj}$ of job $j$ on machine $k$ and the start of '
              'operation $O_{l,j}$ of job $j$ on machine $l$, there is a '
              'transportation delay of at least $T$ units.',
 't_{jkl}=t_{jlk}': 'Job dependent Symmetric transportation delay. Between the '
                    'completion of operation $O_{kj}$ of job $j$ on machine '
                    '$l$ and the start of operation $O_{l,j}$ of job $j$ on '
                    'machine $l$, there is a transportation delay of at least '
                    '$t_{jkl}$ units, which equals $t_{jlk}$.',
 't_{jk}': 'Between the completion of operation $O_{kj}$ of job $j$ on machine '
           '$k$ and the start of operation $O_{k+1,j}$ of job $j$ on machine '
           '$k+1$, there is a transportation delay of at least $t_{jk}$ units.',
 't_{jk}=T': 'Uniform transportation delay. Between the completion of '
             'operation $O_{kj}$ of job $j$ on machine $k$ and the start of '
             'operation $O_{k+1,j}$ of job $j$ on machine $k+1$, there is a '
             'transportation delay of at least $T$ units.',
 't_{kl}': 'Machine pair dependent transportation delay. Between the '
           'completion of operation $O_{kj}$ of job $j$ on machine $k$ and the '
           'start of operation $O_{l,j}$ of job $j$ on machine $l$, there is a '
           'transportation delay of at least $t_{kl}$ units.',
 't_{kl}=t_{lk}': 'Symmetric transportation delay. Between the completion of '
                  'operation $O_{kj}$ of job $j$ on machine $k$ and the start '
                  'of operation $O_{l,j}$ of job $j$ on machine $l$, there is '
                  'a transportation delay of at least $t_{kl}$ units, which '
                  'equals $t_{lk}$.',
 'tree': 'Given general precedence relation in form of a tree, either intree '
         'or outtree.'}
